//! Autogenerating trait implementations for constrained strings
use thiserror::Error;

/// The `Error` type of `TryFrom<String> for $t` implementations generated by
/// `validstr!()`
#[derive(Clone, Debug, Eq, Error, PartialEq)]
#[error("{source}: {string:?}")]
pub(crate) struct TryFromStringError<E> {
    /// The error returned by `$validator`
    pub(crate) source: E,

    /// The string that failed validation
    pub(crate) string: String,
}

/// Autogenerate trait implementations for constrained/"validated" strings
///
/// Given:
///
/// - A type `$t` defined as a tuple struct whose only field is either `String`
///   or a compatible type like [`smartstring::alias::CompactString`]
///
/// - An error type `$err`
///
/// - A function name `$validator` with the signature `(&str) -> Result<(),
///   $err>`
///
/// - A string `$expecting`
///
/// `validstr($t, $err, $validator, $expecting)` defines a number of trait
/// implementations for `$t` that allow for, among other things:
///
/// - Converting `$t` and `&$t` to a `String`
///
/// - Converting `&str` and `String` values to `$t` if & only if they are
///   accepted by `$validator`
///
///     - The error types returned by these operations are `$err` and
///       `TryFromStringError<$err>`, respectively.
///
/// - Comparing `$t` to string values
///
/// - Dereferencing `$t` as a `&str`
///
/// - Using serde to serialize `$t` to a string and deserialize `$t` from a
///   string (with the latter using `$expecting` as the "expecting" message)
macro_rules! validstr {
    ($t:ident, $err:ty, $validator:ident, $expecting:literal) => {
        impl From<$t> for String {
            fn from(value: $t) -> String {
                value.0.into()
            }
        }

        impl From<&$t> for String {
            #[allow(clippy::string_to_string)]
            fn from(value: &$t) -> String {
                value.0.to_string()
            }
        }

        impl std::fmt::Debug for $t {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(f, "{:?}", self.0)
            }
        }

        impl std::fmt::Display for $t {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(f, "{}", self.0)
            }
        }

        impl PartialEq<str> for $t {
            fn eq(&self, other: &str) -> bool {
                self.0 == other
            }
        }

        impl<'a> PartialEq<&'a str> for $t {
            fn eq(&self, other: &&'a str) -> bool {
                &self.0 == other
            }
        }

        impl AsRef<str> for $t {
            fn as_ref(&self) -> &str {
                self.0.as_ref()
            }
        }

        impl std::ops::Deref for $t {
            type Target = str;

            fn deref(&self) -> &str {
                &*self.0
            }
        }

        impl std::str::FromStr for $t {
            type Err = $err;

            fn from_str(s: &str) -> Result<$t, $err> {
                match $validator(s) {
                    Ok(()) => Ok($t(s.into())),
                    Err(e) => Err(e),
                }
            }
        }

        impl TryFrom<String> for $t {
            type Error = crate::validstr::TryFromStringError<$err>;

            fn try_from(s: String) -> Result<$t, Self::Error> {
                match $validator(&s) {
                    Ok(()) => Ok($t(s.into())),
                    Err(source) => Err(crate::validstr::TryFromStringError { source, string: s }),
                }
            }
        }

        #[allow(unused_qualifications)]
        impl serde::Serialize for $t {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                serializer.serialize_str(self.as_ref())
            }
        }

        #[allow(unused_qualifications)]
        impl<'de> serde::Deserialize<'de> for $t {
            fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
            where
                D: serde::de::Deserializer<'de>,
            {
                struct Visitor;

                impl serde::de::Visitor<'_> for Visitor {
                    type Value = $t;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        formatter.write_str($expecting)
                    }

                    fn visit_str<E>(self, input: &str) -> Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        input
                            .parse::<$t>()
                            .map_err(|_| E::invalid_value(serde::de::Unexpected::Str(input), &self))
                    }

                    fn visit_string<E>(self, input: String) -> Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        if $validator(&input).is_ok() {
                            Ok($t(input.into()))
                        } else {
                            Err(E::invalid_value(serde::de::Unexpected::Str(&input), &self))
                        }
                    }
                }

                deserializer.deserialize_string(Visitor)
            }
        }
    };
}
